import config from '../../src/config';
import * as iasql from '../../src/services/iasql'
import { getPrefix, runQuery, runInstall, runUninstall, runApply, finish, execComposeUp, execComposeDown, runSync, } from '../helpers'

const prefix = getPrefix();
const dbAlias = 'ecrtest';
const repositoryName = prefix + dbAlias;
const pubRepositoryName = `pub${prefix}${dbAlias}-${process.env.AWS_REGION ?? 'barf'}`;
const policyMock = '{ "Version": "2012-10-17", "Statement": [ { "Sid": "DenyPull", "Effect": "Deny", "Principal": "*", "Action": [ "ecr:BatchGetImage", "ecr:GetDownloadUrlForLayer" ] } ]}';
const updatePolicyMock = '{ "Version": "2012-10-17", "Statement": [ { "Sid": "DenyPull", "Effect": "Deny", "Principal": "*", "Action": [ "ecr:BatchGetImage" ] } ]}';
const apply = runApply.bind(null, dbAlias);
const sync = runSync.bind(null, dbAlias);
const install = runInstall.bind(null, dbAlias);
const uninstall = runUninstall.bind(null, dbAlias);
const query = runQuery.bind(null, dbAlias);
const modules = ['aws_ecr@0.0.1'];

jest.setTimeout(240000);
beforeAll(async () => await execComposeUp());
afterAll(async () => await execComposeDown(modules));

describe('ECR Integration Testing', () => {
  it('creates a new test db', (done) => void iasql.connect(
    dbAlias,
    process.env.AWS_REGION ?? 'barf',
    process.env.AWS_ACCESS_KEY_ID ?? 'barf',
    process.env.AWS_SECRET_ACCESS_KEY ?? 'barf',
    'not-needed', 'not-needed').then(...finish(done)));

  it('installs the ecr module', install(modules));

  describe('private repository', () => {
    it('adds a new repository', query(`
      INSERT INTO repository (repository_name, scan_on_push, image_tag_mutability)
      VALUES ('${repositoryName}', false, 'MUTABLE');
    `));
  
    it('undo changes', sync());

    it('check adds a new repository', query(`
      SELECT *
      FROM repository
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => expect(res.length).toBe(0)));

    it('adds a new repository', query(`
      INSERT INTO repository (repository_name, scan_on_push, image_tag_mutability)
      VALUES ('${repositoryName}', false, 'MUTABLE');
    `));

    it('check adds a new repository', query(`
      SELECT *
      FROM repository
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => {
      expect(res.length).toBe(1);
      expect(res[0]['scan_on_push']).toBe(false);
      return expect(res[0]['image_tag_mutability']).toBe('MUTABLE');
    }));
  
    it('applies the reporsitory change', apply());
  
    it('tries to update a repository autogenerated field', query(`
      UPDATE repository SET repository_arn = '${repositoryName}arn' WHERE repository_name = '${repositoryName}';
    `));

    it('applies change which will undo it', apply());

    it('tries to update a repository field', query(`
      UPDATE repository SET scan_on_push = true WHERE repository_name = '${repositoryName}';
    `));
  
    it('applies the change', apply());

    it('check adds a new repository', query(`
      SELECT *
      FROM repository
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => {
      expect(res.length).toBe(1);
      return expect(res[0]['scan_on_push']).toBe(true);
    }));
  
    it('adds a new repository policy', query(`
      INSERT INTO repository_policy (repository_id, policy_text)
      SELECT id, '${policyMock}'
      FROM repository
      WHERE repository_name = '${repositoryName}';
    `));
  
    it('applies the change', apply());

    it('check adds a new repository policy', query(`
      SELECT *
      FROM repository_policy
      INNER JOIN repository ON repository.id = repository_policy.repository_id
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => expect(res.length).toBe(1)));

    it('tries to update a repository policy autogenerated field', query(`
      UPDATE repository_policy AS arp
      SET registry_id = '${repositoryName}registry'
      FROM repository AS ar
      WHERE ar.repository_name = '${repositoryName}' AND ar.id = arp.repository_id;
    `));

    it('applies change which will undo it', apply());

    it('tries to update a repository field', query(`
      UPDATE repository_policy AS arp
      SET policy_text = '${updatePolicyMock}'
      FROM repository AS ar
      WHERE ar.repository_name = '${repositoryName}' AND ar.id = arp.repository_id;
    `));
  
    it('applies the change', apply());

    it('deletes the repository policy', query(`
      DELETE FROM repository_policy AS arp
      USING repository AS ar
      WHERE ar.repository_name = '${repositoryName}' AND ar.id = arp.repository_id;
    `));

    it('applies the delete repository policy', apply());

    it('check deletes the repository policy', query(`
      SELECT *
      FROM repository_policy
      INNER JOIN repository ON repository.id = repository_policy.repository_id
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => expect(res.length).toBe(0)));

    it('uninstalls the ecr module', uninstall(modules));
  
    it('installs the ecr module', install(modules));

    it('deletes the repository', query(`
      DELETE FROM repository
      WHERE repository_name = '${repositoryName}';
    `));

    it('applies deletes the repository', apply());

    it('check deletes the repository', query(`
      SELECT scan_on_push, image_tag_mutability
      FROM repository
      WHERE repository_name = '${repositoryName}';
    `, (res: any[]) => expect(res.length).toBe(0)));
  });

  describe('public repository', () => {
    it('adds a new public repository', query(`
      INSERT INTO public_repository (repository_name)
      VALUES ('${pubRepositoryName}');
    `));
  
    it('undo changes', sync());
  
    it('check adds a new public repository', query(`
      SELECT *
      FROM public_repository
      WHERE repository_name = '${pubRepositoryName}';
    `, (res: any[]) => expect(res.length).toBe(0)));

    it('adds a new public repository', query(`
      INSERT INTO public_repository (repository_name)
      VALUES ('${pubRepositoryName}');
    `));

    it('check adds a new public repository', query(`
      SELECT *
      FROM public_repository
      WHERE repository_name = '${pubRepositoryName}';
    `, (res: any[]) => expect(res.length).toBe(1)));

    it('applies the public repository change', apply());

    it('tries to update a public repository autogenerated field', query(`
      UPDATE public_repository SET repository_arn = '${pubRepositoryName}arn' WHERE repository_name = '${pubRepositoryName}';
    `));

    it('applies change which will undo it', apply());

    it('check update public repository (noop)', query(`
      SELECT *
      FROM public_repository
      WHERE repository_name = '${pubRepositoryName}';
    `, (res: any[]) => expect(res.length).toBe(1)));
  
    it('uninstalls the ecr module', uninstall(modules));
  
    it('installs the ecr module', install(modules));
  
    it('deletes the public repository', query(`
      DELETE FROM public_repository
      WHERE repository_name = '${pubRepositoryName}';
    `));

    it('applies the log group change (last time)', apply());

    it('check deletes the public repository', query(`
      SELECT *
      FROM public_repository
      WHERE repository_name = '${pubRepositoryName}';
    `, (res: any[]) => expect(res.length).toBe(0)));
  });

  it('deletes the test db', (done) => void iasql
    .disconnect(dbAlias, 'not-needed')
    .then(...finish(done)));
});

describe('ECR install/uninstall', () => {
  it('creates a new test db', (done) => void iasql.connect(
    dbAlias,
    'us-east-1', // Share region with common tests
    process.env.AWS_ACCESS_KEY_ID ?? 'barf',
    process.env.AWS_SECRET_ACCESS_KEY ?? 'barf',
    'not-needed', 'not-needed').then(...finish(done)));

  it('installs the ECR module', install(modules));

  it('uninstalls the ECR module', uninstall(modules));

  it('installs all modules', (done) => void iasql.install(
    [],
    dbAlias,
    config.dbUser,
    true).then(...finish(done)));

  it('uninstalls the ECR module', uninstall(['aws_ecr@0.0.1', 'aws_ecs_fargate@0.0.1']));

  it('installs the ECR module', install(modules));

  it('deletes the test db', (done) => void iasql
    .disconnect(dbAlias, 'not-needed')
    .then(...finish(done)));
});
