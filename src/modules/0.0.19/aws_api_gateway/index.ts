import {
  ApiGatewayV2,
  Api as ApiAWS,
  CreateApiCommandInput,
  CreateApiCommandOutput,
  UpdateApiCommandInput,
} from '@aws-sdk/client-apigatewayv2';

import { AWS, crudBuilder2, crudBuilderFormat, paginateBuilder } from '../../../services/aws_macros';
import { Context, Crud2, MapperBase, ModuleBase } from '../../interfaces';
import { Api, Protocol } from './entity';

class ApiMapper extends MapperBase<Api> {
  module: AwsApiGatewayModule;
  entity = Api;
  equals = (a: Api, b: Api) => {
    const res =
      Object.is(a.description, b.description) &&
      Object.is(a.disableExecuteApiEndpoint, b.disableExecuteApiEndpoint) &&
      Object.is(a.protocolType, b.protocolType) &&
      Object.is(a.version, b.version) &&
      Object.is(a.name, b.name);
    return res;
  };

  getApi = crudBuilder2<ApiGatewayV2, 'getApi'>('getApi', ApiId => ({ ApiId }));

  getApis = crudBuilderFormat<ApiGatewayV2, 'getApis', ApiAWS[] | undefined>(
    'getApis',
    () => ({}),
    res => res?.Items,
  );

  async createApi(client: ApiGatewayV2, input: CreateApiCommandInput) {
    const newRestApi = await client.createApi(input);
    return newRestApi;
  }

  deleteApi = crudBuilder2<ApiGatewayV2, 'deleteApi'>('deleteApi', ApiId => ({ ApiId }));

  updateApi = crudBuilder2<ApiGatewayV2, 'updateApi'>('updateApi', input => input);

  cloud = new Crud2<Api>({
    create: async (rs: Api[], ctx: Context) => {
      const client = (await ctx.getAwsClient()) as AWS;
      const out = [];
      for (const r of rs) {
        // add a default protocol
        if (!r.protocolType) r.protocolType = Protocol.HTTP;

        // if we have an id already, check if exists
        const input: CreateApiCommandInput = {
          Name: r.name,
          Description: r.description,
          DisableExecuteApiEndpoint: r.disableExecuteApiEndpoint,
          ProtocolType: r.protocolType.toString(),
          Version: r.version,
        };
        const result: CreateApiCommandOutput = await this.createApi(client.apiGatewayClient, input);
        if (result) {
          const newApi = this.apiMapper(result);
          // use the same ID as the one inserted, and set the name as is optionally returned
          newApi.id = r.id;
          newApi.name = r.name;
          await this.module.api.db.update(newApi, ctx);
          out.push(newApi);
        }
      }
      return out;
    },
    read: async (ctx: Context, apiId?: string) => {
      const client = (await ctx.getAwsClient()) as AWS;
      if (apiId) {
        const rawApi = await this.getApi(client.apiGatewayClient, apiId);
        if (!rawApi) return undefined;
        return this.apiMapper(rawApi);
      } else {
        const rawApis = (await this.getApis(client.apiGatewayClient)) ?? [];
        const out = [];
        for (const i of rawApis) {
          const outApi = this.apiMapper(i);
          if (outApi) out.push(outApi);
        }
        return out;
      }
    },
    updateOrReplace: (a: Api, b: Api) => 'update',
    update: async (rs: Api[], ctx: Context) => {
      const client = (await ctx.getAwsClient()) as AWS;
      const out = [];
      for (const r of rs) {
        const cloudRecord = ctx?.memo?.cloud?.Api?.[r.apiId ?? ''];
        const isUpdate = Object.is(this.module.api.cloud.updateOrReplace(cloudRecord, r), 'update');
        if (isUpdate) {
          // api id is generated by aws, we cannot modify it
          if (cloudRecord.protocolType !== r.protocolType) {
            // restore
            cloudRecord.id = r.id;
            await this.module.api.db.update(cloudRecord, ctx);
            out.push(cloudRecord);
          } else {
            const input: UpdateApiCommandInput = {
              ApiId: r.apiId,
              Name: r.name,
              Description: r.description,
              DisableExecuteApiEndpoint: r.disableExecuteApiEndpoint,
              Version: r.version,
            };
            const res = await this.updateApi(client.apiGatewayClient, input);
            if (res) {
              const newApi = this.apiMapper(res);
              newApi.name = r.name;
              newApi.id = r.id;
              // Save the record back into the database to get the new fields updated
              await this.module.api.db.update(newApi, ctx);
              out.push(newApi);
            } else {
              throw new Error('Error updating API');
            }
          }
        }
      }
      return out;
    },
    delete: async (rs: Api[], ctx: Context) => {
      const client = (await ctx.getAwsClient()) as AWS;
      for (const r of rs) {
        await this.deleteApi(client.apiGatewayClient, r.apiId);
      }
    },
  });

  constructor(module: AwsApiGatewayModule) {
    super();
    this.module = module;
    super.init();
  }

  apiMapper(instance: any) {
    const r: Api = new Api();
    if (!instance.ApiId) throw new Error('Received an API without a id');
    if (!instance.Name) throw new Error('Received an API without a name');
    r.description = instance.Description;
    r.disableExecuteApiEndpoint = instance.DisableExecuteApiEndpoint;
    r.name = instance.Name;
    r.apiId = instance.ApiId;
    if (instance.ProtocolType) {
      const typedProtocol = instance.ProtocolType as keyof typeof Protocol;
      r.protocolType = Protocol[typedProtocol];
    }
    r.version = instance.Version;
    return r;
  }
}

class AwsApiGatewayModule extends ModuleBase {
  api: ApiMapper;

  constructor() {
    super();
    this.api = new ApiMapper(this);
    super.init();
  }
}
export const awsApiGatewayModule = new AwsApiGatewayModule();
