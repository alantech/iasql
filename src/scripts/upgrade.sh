#!/bin/bash

set -vx

# TODO: Also need to add an `UPGRADE` audit log type we can add in there to make it clear when prior logs are no longer fully "trustworthy" for the purposes of re-generating SQL statements from them.

# Check if there's any tables in the metadata database, in case this is a first-time run
HAS_IASQL_DATABASE=$(psql iasql_metadata -qtc "
	SELECT table_name
	FROM information_schema.tables
	WHERE table_name = 'iasql_database';
")

if [ "$HAS_IASQL_DATABASE" != "" ]; then
	# Get all user database names
	USER_DATABASES=$(psql iasql_metadata -qtc "
		SELECT pg_name
		FROM iasql_database;
	")
	for DB in $USER_DATABASES
	do
		echo Checking $DB ...

		# Get the engine and DB versions, figure out which is the newest and if that newest version is
		# a beta release. *Always* re-run the upgrade on beta releases, and if not a beta release, run
		# the upgrade only if the DB is an earlier version than the engine

		ENGINE_VERSION=$(jq -r .version /engine/package.json | xargs) # xargs is the recommended way to 'trim' strings. Oh Bash...

		DB_VERSION=$(psql $DB -qtc "
			SELECT split_part(name, '@', 2) FROM iasql_module LIMIT 1;
		" | xargs)

		LATEST_VERSION=$(/engine/node_modules/.bin/semver $ENGINE_VERSION $DB_VERSION | tail -n 1 | xargs)

		[[ "$LATEST_VERSION" == *"-beta" ]]
		IS_BETA_VERSION=$?

		[[ "$DB_VERSION" == "$LATEST_VERSION" ]]
		DB_IS_LATEST=$?

		SHOULD_UPGRADE=$IS_BETA_VERSION || ! $DB_IS_LATEST

		if [[ $SHOULD_UPGRADE ]]; then
			echo $DB to be upgraded!

			# It's not possible to actually re-install the new modules without the engine, the RPC SQL is
			# generated by Typescript code, so instead we're gonna grab the relevant info, stuff it into
			# temporary files, then continue in Typescript hooking into the startup process, which will
			# look for the `/tmp/upgrade/` path to decide if it needs to execute or not.

			mkdir -p /tmp/upgrade/$DB

			# Get list of modules that need to be re-installed
			MODULE_LIST=$(psql $DB --csv -tc "
				SELECT split_part(name, '@', 1) AS module FROM iasql_module;
			")
			echo $MODULE_LIST > /tmp/upgrade/$DB/module_list

			for MODULE in $MODULE_LIST
			do
				if [[ "$MODULE" == "aws_account" ]]; then
					# TODO: Figure out a more generic way of dealing with non-synced user data
					psql $DB --csv -tc "
						SELECT access_key_id, secret_access_key FROM aws_credentials;
					" > /tmp/upgrade/$DB/creds

					psql $DB --csv -tc "
						SELECT region FROM aws_regions WHERE is_enabled = TRUE;
					" > /tmp/upgrade/$DB/regions_enabled

					psql $DB --csv -tc "
						SELECT region FROM aws_regions WHERE is_default = TRUE;
					" > /tmp/upgrade/$DB/default_region
				fi
			done

			# All IaSQL DBs have an audit log, so this doesn't need a conditional check
			psql $DB -tc "
        SELECT array_to_json(ARRAY(SELECT row_to_json(iasql_audit_log) FROM iasql_audit_log));
			" > /tmp/upgrade/$DB/audit_log

			# Triggers
			TRIGGERS=$(psql $DB --csv -tc "
        SELECT DISTINCT pg_proc.proname, information_schema.triggers.event_object_table
        FROM pg_proc
        INNER JOIN pg_type ON pg_type.oid = pg_proc.prorettype
        INNER JOIN pg_namespace ON pg_namespace.oid = pg_proc.pronamespace
        INNER JOIN information_schema.triggers ON information_schema.triggers.trigger_name = pg_proc.proname
        WHERE pg_type.typname = 'trigger' AND pg_namespace.nspname = 'public';
			")
      for TRIGGER_ROW in $TRIGGERS
      do
        IFS="," read TRIGGER_FN TRIGGER_TBL <<< "$TRIGGER_ROW"
        psql $DB -c "DROP TRIGGER \"$TRIGGER_FN\" ON \"$TRIGGER_TBL\";"
      done

      # Check constraints
      CHECKS=$(psql $DB --csv -tc "
        SELECT DISTINCT pgc.conname, ccu.table_name
        FROM pg_constraint pgc
        INNER JOIN pg_namespace nsp ON nsp.oid = pgc.connamespace
        INNER JOIN pg_class  cls ON pgc.conrelid = cls.oid
        LEFT OUTER JOIN information_schema.constraint_column_usage ccu ON pgc.conname = ccu.constraint_name AND nsp.nspname = ccu.constraint_schema
        WHERE contype = 'c' AND ccu.table_schema = 'public';
      ")
      for CHECK_ROW in $CHECKS
      do
        IFS="," read CHECK_CNST CHECK_TBL <<< "$CHECK_ROW"
        psql $DB -c "ALTER TABLE \"$CHECK_TBL\" DROP CONSTRAINT \"$CHECK_CNST\";"
      done

      # Default values
      DEFAULTS=$(psql $DB --csv -tc "
        SELECT table_name, column_name
        FROM information_schema.columns
        WHERE column_default IS NOT NULL
          AND table_schema = 'public';
      ")
      for DEFAULT_ROW in $DEFAULTS
      do
        IFS="," read DEFAULT_TBL DEFAULT_COL <<< "$DEFAULT_ROW"
        psql $DB -c "ALTER TABLE \"$DEFAULT_TBL\" ALTER COLUMN \"$DEFAULT_COL\" DROP DEFAULT;"
      done

      IFS=$'\n'

			# Other functions. The SQL generates the statements to run because it's too hard to write Bash to do it
			FUNCS=$(psql $DB -qtc "
        SELECT 'DROP FUNCTION ' || proname || '(' || CASE WHEN args IS NULL THEN '' ELSE array_to_string(args, ', ', NULL) END || ');'
        FROM (
          SELECT proname, args
          FROM (
            SELECT oid, proname, array_agg(typname) AS args
            FROM (
              SELECT f.idx, f.oid, f.proname, pg_type.typname
              FROM (
                SELECT ROW_NUMBER() OVER() AS idx, pg_proc.oid, pg_proc.proname, unnest(pg_proc.proargtypes) AS argtype
                FROM pg_proc
                INNER JOIN pg_type ON pg_type.oid = pg_proc.prorettype
                INNER JOIN pg_namespace ON pg_namespace.oid = pg_proc.pronamespace
                INNER JOIN pg_proc p2 ON pg_type.typoutput = p2.oid
                WHERE p2.proname != 'trigger_out'
                  AND pg_namespace.nspname = 'public'
                  AND NOT starts_with(pg_proc.prosrc, pg_proc.proname)
                  AND NOT starts_with(pg_proc.proname, pg_proc.prosrc)
              ) AS f
              LEFT OUTER JOIN pg_type ON pg_type.oid = f.argtype
            ) AS f
            GROUP BY oid, proname, idx
            ORDER BY idx
          ) AS f
          UNION
          SELECT proname, args
          FROM (
            SELECT pg_proc.proname, NULL::name[] AS args
            FROM pg_proc
            INNER JOIN pg_type ON pg_type.oid = pg_proc.prorettype
            INNER JOIN pg_namespace ON pg_namespace.oid = pg_proc.pronamespace
            INNER JOIN pg_proc p2 ON pg_type.typoutput = p2.oid
            WHERE p2.proname != 'trigger_out'
              AND pg_namespace.nspname = 'public'
              AND NOT starts_with(pg_proc.prosrc, pg_proc.proname)
              AND NOT starts_with(pg_proc.proname, pg_proc.prosrc)
              AND pg_proc.proargtypes[0] IS NULL
          ) AS f
        ) AS f;
			")
      for DEL_FN in $FUNCS
      do
        psql $DB -c "$DEL_FN"
      done

			# Foreign key indexes
			FKS=$(psql $DB --csv -tc "
        SELECT DISTINCT rc.constraint_name, tc.table_name
        FROM information_schema.referential_constraints rc
        INNER JOIN information_schema.table_constraints tc ON tc.constraint_name = rc.constraint_name;
			");
      for FK_ROW in $FKS
      do
        IFS="," read FK_CNST FK_TBL <<< "$FK_ROW"
        psql $DB -c "ALTER TABLE \"$FK_TBL\" DROP CONSTRAINT \"$FK_CNST\";"
      done

			# Non-foreign key indexes
			PKS=$(psql $DB --csv -tc "
				SELECT DISTINCT kcu.constraint_name, tc.table_name
				FROM information_schema.key_column_usage kcu
        INNER JOIN information_schema.table_constraints tc ON tc.constraint_name = kcu.constraint_name
				LEFT OUTER JOIN information_schema.referential_constraints rc ON rc.constraint_name = kcu.constraint_name
				WHERE kcu.constraint_schema = 'public' AND rc.constraint_name IS NULL;
			")
      for PK_ROW in $PKS
      do
        IFS="," read PK_CNST PK_TBL <<< "$PK_ROW"
        psql $DB -c "ALTER TABLE \"$PK_TBL\" DROP CONSTRAINT \"$PK_CNST\";"
      done

			# Tables
			TABLES=$(psql $DB --csv -tc "
				SELECT table_name
				FROM information_schema.tables
				WHERE table_schema = 'public';
			")
      for TABLE in $TABLES
      do
        psql $DB -c "DROP TABLE \"$TABLE\";"
      done

			# Enums
			ENUMS=$(psql $DB --csv -tc "
				SELECT DISTINCT t.typname as enum_name
				FROM pg_type t
				INNER JOIN pg_enum e ON t.oid = e.enumtypid
				INNER JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
				WHERE n.nspname = 'public';
			")
      for ENUM in $ENUMS
      do
        psql $DB -c "DROP TYPE \"$ENUM\";"
      done

      echo Part 1 of 3 for $DB complete!
		fi
	done
fi