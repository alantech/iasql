# Contributing

Thanks for your interest in helping improve IaSQL! ðŸŽ‰

If you are looking for IaSQL's documentation, go here instead: https://docs.iasql.com/

This document is for people who want to contribute code to IaSQL. There are also other ways to contribute, such as reporting bugs, creating feature requests, helping other users in our forums, Discord etc.

## How IaSQL works

IaSQL is an eventually-consistent design where the SQL tables are the source of truth. This means that the state that users create in the SQL tables is what things will be pushed towards, *not* reading the state from the cloud and exposing it to end users for querying. It's eventually consistent so multiple changes can be queued up without latency on the user's side and any difference between reality and what's in the tables will be treated as an issue to be corrected and a cloud migration to perform.

There are a couple of places (like security group IDs) where we can't avoid the ID being generated by the cloud instead of ourselves within postgres. These will need to be nullable columns that we eventually fill in once the security group is created during the creation process. Similarly, things that depend on other things with nullable columns will fail if that column is still null, so `is not null` checks should be included in the queries involving them, though this isn't a hard requirement, as it being null will just cause the API call to fail (but better to not do that when we know it won't work in the first place).

## How to run IaSQL locally

This repo houses the IaSQL engine which is a Node.js HTTP server written in Typescript. Make sure docker is installed locally and bring up the Postgres engine and Node.js server by running

```
IASQL_ENV=local docker-compose up --build
```

`IASQL_ENV=local` configures the engine to use the values from `src/config/local.ts`. The Postgres superadmin user will be `postgres` and its password `test`. The Node.js server will start on port 8088. To create a new database in your local Postgres engine and connect it to an AWS account (and whatever region you prefer) send the following HTTP request to the local engine:


```bash
curl \
  --request POST \
  --url 'http://localhost:8088/v1/db/connect/' \
  --show-error --silent --fail \
  --header 'content-type: application/json' \
  --data '{
    "dbAlias": "<db_name>",
    "awsRegion": "${process.env.AWS_REGION}",
    "awsAccessKeyId": "${process.env.AWS_ACCESS_KEY_ID}",
    "awsSecretAccessKey": "${process.env.AWS_SECRET_ACCESS_KEY}"
  }'
```

Now connect to the database is a simple as:

```bash
psql postgres://postgres:test@127.0.0.1:5432/<db_name>
```

You are off to the races! If you wish to disconnect the local database from the AWS account and remove it from the engine simply run:

```bash
curl -f -s -S http://localhost:8088/v1/db/disconnect/<db_name>
```

## How to develop IaSQL

Instead of a centralized linear list of migrations, we have a module-based approach to allow different collections of tables to be inserted or removed as desired by the end users. These modules need to declare what modules they depend on and what resources (tables, stored procedures, etc) they depend on.

Development of a new module is expected to follow this pattern:

1. Create the module directory, and create `entity` and `migration` directories inside of it.
2. Create the entity or entities in the `entity` directory and export them all from the `index.ts` file (or just define them in there).
3. Run the `yarn gen-module my_new_module_name` script and have it generate the migration file. (`my_new_module_name` needs to match the directory name for the module in question.)
4. Write the module's `index.ts` file. It must implement the `MapperInterface` inside of `modules/interfaces.ts`, which also requires importing and constructing `Mapper` and `Crud` objects.

Development of an existing module is expected to follow this pattern:

1. Make the changes to the entities that you want to make.
2. Run the `yarn gen-module my_existing_module_name` script and have it generate a new migration file. (`my_existing_module_name` needs to match the directory name for the module in question.)
5. Commit the removal of the old migration and add in the new one. You can only have one migration file per module.

### Migrations

IaSQL's modules require the migration file to either be generated by TypeORM, or to be in that form, which is a typescript file that exports a single class with two methods: an `async up` and an `async down`. They both accept a TypeORM `QueryRunner` object and return nothing. Any usage of this queryRunner as supported by TypeORM is allowed, but the simplest usage is `await queryRunner.query(someSqlString);`.

The `up` defines the creation of the SQL schema necessary for your module, and `down` is the removal of that same schema. If you do not use `yarn gen-module` to create this file, it is up to you to make sure the downgrade path fully removes everything added in the upgrade path.

## How to test IaSQL locally

To run the integration tests locally make sure to point to an existing AWS account by setting the following environment variables.

```
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=
```

Run `yarn coverage:local` which will set the `IASQL_ENV` to `test` for you. To run a specific test file only, simply pass it as a parameter `yarn coverage:local test/modules/aws-cloudwatch-integration.ts`

## How to test IaSQL via CI/CD

### Common integration

Common tests are inside `test/common/` directory. This tests run sequentially and they use the `Testing` account. To add a new test just create the file inside the common directory and it will run automatically.

### Modules

Modules tests are inside `test/modules/` directory. Modules tests run in parallel with each other but sequentially within each module file and each use a specific account per module to avoid rate limits per account. To add a new test:

- Create the test file inside `test/modules`. The current pattern to name the file is `aws-<aws-service>-integration`.
- Create a new AWS account under the `iasql` organization:
  
  - Add account following the same pattern for the name `aws-<aws-service>-integration` and the email `dev+aws-<aws-service>-integration`.
  - Move the account to the Integration testing organization Unit. This way all the resources created by these accounts will be isolated and unrrelated to the other environments.
  - Reset password for the account
  - Generate account credentials

- Save account credentials as Github actions secret. The name of the secrets should follow the pattern:
  
  - `AWS_ACCESS_KEY_ID_<name of the test file in uppercase and replacing - with _>`
  - `AWS_SECRET_ACCESS_KEY_<name of the test file in uppercase and replacing - with _>`

- Run the tests. It will parallelize the test file and use the new credentials automatically.