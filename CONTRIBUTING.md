# Contributing

Thanks for your interest in helping improve IaSQL! ðŸŽ‰

If you are looking for IaSQL's documentation, go here instead: https://docs.iasql.com/

This document is for people who want to contribute code to IaSQL. There are also other ways to contribute, such as reporting bugs, creating feature requests, helping other users in our forums, Discord etc.

## How IaSQL works

IaSQL is an eventually-consistent design where the SQL tables are the source of truth. This means that the state that users create in the SQL tables is what things will be pushed towards, *not* reading the state from the cloud and exposing it to end users for querying. It's eventually consistent so multiple changes can be queued up without latency on the user's side and any difference between reality and what's in the tables will be treated as an issue to be corrected and a cloud migration to perform.

There are a couple of places (like security group IDs) where we can't avoid the ID being generated by the cloud instead of ourselves within postgres. These will need to be nullable columns that we eventually fill in once the security group is created during the creation process. Similarly, things that depend on other things with nullable columns will fail if that column is still null, so `is not null` checks should be included in the queries involving them, though this isn't a hard requirement, as it being null will just cause the API call to fail (but better to not do that when we know it won't work in the first place).

## How to build IaSQL

This repo houses IaSQL engine which is called by the [cli](https://github.com/iasql/cli). Set your `.env` file based on the values from `src/config.ts`, make sure docker is installed locally and bring up the postgres engine and node.js server by running

```
docker-compose up --build
```

## How to develop IaSQL

Instead of a centralized linear list of migrations, we have a module-based approach to allow different collections of tables to be inserted or removed as desired by the end users. These modules need to declare what modules they depend on and what resources (tables, stored procedures, etc) they depend on.

Development of a new module is expected to follow this pattern:

1. Create the module directory, and create `entity` and `migration` directories inside of it.
2. Create the entity or entities in the `entity` directory and export them all from the `index.ts` file (or just define them in there).
3. Run the `yarn gen-module my_new_module_name` script and have it generate the migration file. (`my_new_module_name` needs to match the directory name for the module in question.)
4. Write the module's `index.ts` file. It must implement the `MapperInterface` inside of `modules/interfaces.ts`, which also requires importing and constructing `Mapper` and `Crud` objects. The auto-generated migration files can be imported and attached as appropriate. Generally `up` is attached to `postinstall` and `down` is attached to `preremove`. The other migration hooks are for more complex situations.

Development of an existing module is expected to follow this pattern:

1. Remove the entities and migrations of the dependent modules, if any.
2. Remove the migration of the module you are trying to modify and comment out the usage of this migration in the module index file.
3. Make the changes to the entities that you want to make.
4. Run the `yarn gen-module my_existing_module_name` script and have it generate a new migration file. (`my_existing_module_name` needs to match the directory name for the module in question.)
5. Attach the new migration file to the index file and git restore dependent modules.

### Migrations

This part is modeled partly on Debian packages, and partly on Node packages. (It's mostly the completeness of options that are taken from Node). There are four kinds of events encoded in this: upgrade, downgrade, install, and remove.

Upgrade and Downgrade are when the module is already installed and the version is being changed. Install is when the module is not present and the version in question is being added, and Remove is for getting rid of the module.

The Pre- and Post- prefixes on these events are for the ordering that it will be called in relation to any dependencies that also need to have a migration run. The Pre- prefix means that it will run *before* all of its dependencies' runs, and the Post- prefix for *after* all of its dependencies have run. (Like the double-bubbling in the browser event system, btw.) Essentially this means that the dependency tree is linearized twice, first with the leaf nodes being earlier in the list for all of the Pre- migrations to be run, then with the root nodes being earlier in the list for all of the Post- migrations.

In general, `install` and `remove` will almost always use only `postinstall` and `preremove`. Why? When installing, you wait for the schemas for your dependencies to be set up, then you run your own schema and attach the foreign key references from them to your own table(s), and when you're removing, you need to remove your foreign key references and your tables before your dependencies can be properly cleaned up.

For `upgrade` and `downgrade`, though, it's likely that both `pre` and `post` will be used in both directions when they are used. Why? If you're upgrading your library and also upgrading the dependency version at the same time, if any columns you are attached to are changing or are being removed, you need to run a migration before they are upgraded to detach your foreign key(s) from them, and then after they are done you need to run a migration to re-attach to (or otherwise deal with) the new schema.

## How to test IaSQL locally

To run the integration tests locally make sure to set the following environment variables and run `yarn coverage:local`.
And make sure you set following environment variables.

```
DB_HOST=localhost
PORT=8088
SENTRY_ENABLED=false
IRONPLANS_TOKEN=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
```

To run a specific test file only, simply pass it as a parameter `yarn coverage:local test/modules/aws-cloudwatch-integration.ts`

## How to test IaSQL via CI/CD

### Common integration

Common tests are inside `test/common/` directory. This tests run sequentially and they use the `Testing` account. To add a new test just create the file inside the common directory and it will run automatically.

### Modules

Modules tests are inside `test/modules/` directory. Modules tests run in parallel with each other but sequentially within each module file and each use a specific account per module to avoid rate limits per account. To add a new test:

- Create the test file inside `test/modules`. The current pattern to name the file is `aws-<aws-service>-integration`.
- Create a new AWS account under the `iasql` organization:
  
  - Add account following the same pattern for the name `aws-<aws-service>-integration` and the email `dev+aws-<aws-service>-integration`.
  - Move the account to the Integration testing organization Unit. This way all the resources created by these accounts will be isolated and unrrelated to the other environments.
  - Reset password for the account
  - Generate account credentials

- Save account credentials as Github actions secret. The name of the secrets should follow the pattern:
  
  - `AWS_ACCESS_KEY_ID_<name of the test file in uppercase and replacing - with _>`
  - `AWS_SECRET_ACCESS_KEY_<name of the test file in uppercase and replacing - with _>`

- Run the tests. It will parallelize the test file and use the new credentials automatically.